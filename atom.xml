<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[编程之路]]></title>
  <link href="blog.codingroad.com/atom.xml" rel="self"/>
  <link href="blog.codingroad.com/"/>
  <updated>2018-07-30T11:36:43+08:00</updated>
  <id>blog.codingroad.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[Python 串口加GUI编程【预告】]]></title>
    <link href="blog.codingroad.com/python-gui-serial.html"/>
    <updated>2018-07-13T15:30:23+08:00</updated>
    <id>blog.codingroad.com/python-gui-serial.html</id>
    <content type="html"><![CDATA[
<p>本周项目，冯总给介绍了一个活，需要用到串口和GUI，这两个方面我从未尝试过，准备折腾一把。</p>

<p>主要用 <code>tkinter</code> 和 <code>serial</code> 两个模块</p>

<h1 id="toc_0"></h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用python分析了20万场吃鸡数据]]></title>
    <link href="blog.codingroad.com/python-get-and-analysis-pubg-mobile-data.html"/>
    <updated>2018-07-08T23:21:30+08:00</updated>
    <id>blog.codingroad.com/python-get-and-analysis-pubg-mobile-data.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">背景</a>
</li>
<li>
<a href="#toc_1">Step 1 分析数据接口</a>
<ul>
<li>
<a href="#toc_2">使用Charles抓包</a>
<ul>
<li>
<a href="#toc_3">抓包实现</a>
</li>
<li>
<a href="#toc_4">https加密流量的处理</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">数据接口</a>
<ul>
<li>
<a href="#toc_6">1. 获取用户信息接口</a>
</li>
<li>
<a href="#toc_7">2. 获取用户战绩列表接口</a>
</li>
<li>
<a href="#toc_8">3. 获取用户战绩详情接口</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_9">Step 2 爬取数据</a>
<ul>
<li>
<a href="#toc_10">使用requests请求接口获取数据</a>
</li>
<li>
<a href="#toc_11">使用redis来标记已经爬取过的信息</a>
</li>
<li>
<a href="#toc_12">使用celery来管理队列</a>
</li>
<li>
<a href="#toc_13">开始抓取</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">Step 3 数据分析</a>
<ul>
<li>
<a href="#toc_15">分析方案</a>
</li>
<li>
<a href="#toc_16">分析结果</a>
<ul>
<li>
<a href="#toc_17">1. 平均用户日在线时长2小时</a>
</li>
<li>
<a href="#toc_18">2. 女性角色被救次数高于男性</a>
</li>
<li>
<a href="#toc_19">3. 女性角色救人次数高于男性</a>
</li>
<li>
<a href="#toc_20">4. 周五大家最忙</a>
</li>
<li>
<a href="#toc_21">5. 晚上22点是游戏高峰</a>
</li>
<li>
<a href="#toc_22">6. 最远击杀距离639米</a>
</li>
<li>
<a href="#toc_23">7. 能拿到 救死扶伤 称号才是最高荣耀</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_24">结尾</a>
</li>
</ul>


<hr>

<p>首先，神枪镇楼<br/>
<img src="media/15310632907202/15310635540917.jpg" alt=""/></p>

<h2 id="toc_0">背景</h2>

<p>最近老板爱上了吃鸡（手游：全军出击），经常拉着我们开黑，只能放弃午休的时间，陪老板在沙漠里奔波。</p>

<p>上周在在微信游戏频道看战绩的时候突发奇想，是不是可以通过这个方式抓取到很多战斗数据，然后分析看看有什么规律。</p>

<p><img src="media/15310632907202/15311076652700.jpg" alt="" style="width:307px;"/></p>

<blockquote>
<p>秀一波战绩，开黑情况下我们团队吃鸡率非常高，近100场吃鸡次数51次</p>
</blockquote>

<p>简单评估了一下，觉得可行，咱就撸起袖子干。</p>

<h2 id="toc_1">Step 1 分析数据接口</h2>

<p>第一步当然是把这些战绩数据采集下来，首先我们需要了解页面背后的故事。去看看页面是如何获取战斗数据的。</p>

<h3 id="toc_2">使用Charles抓包</h3>

<h4 id="toc_3">抓包实现</h4>

<p>在Mac下推荐使用工具Charles来从协议层抓取手机上的流量，原理就是在Mac上开启一个代理服务器，然后将手机的网络代理设置为Mac，这样手机上的所有流量都会经过我们的代理服务器了。</p>

<p>大致流程如下：</p>

<pre><code class="language-sequence">participant iPhone
participant MacBook Charles
participant 微信平台

iPhone-&gt;MacBook Charles:请求game.weixin.qq.com
MacBook Charles-&gt;微信平台:转发请求
微信平台--&gt;MacBook Charles:响应
MacBook Charles--&gt;iPhone:转发响应
</code></pre>

<h4 id="toc_4">https加密流量的处理</h4>

<p>在实际操作的时候发现微信所有的流量都走了HTTPS，导致我们的抓到的都是加密数据，对我们没有任何参考意义。</p>

<p>经过研究，可以通过在手机和电脑都安装Charles根证书的方式来实现对Https流量的分析，具体操作可以参考：</p>

<ul>
<li><a href="https://blog.csdn.net/qq_30259339/article/details/53981448">charles mac下https抓包和iphone https抓包</a></li>
<li><a href="https://www.jianshu.com/p/4005cf4f370d">解决Charles无法正常抓包iOS 11中的Https请求</a></li>
</ul>

<p>安装证书后，我们的流量大致是这样子的</p>

<pre><code class="language-sequence">participant iPhone
participant MacBook Charles
participant 微信平台

iPhone-&gt;MacBook Charles:https握手请求
MacBook Charles-&gt;MacBook Charles:假装自己是服务器
MacBook Charles--&gt;iPhone:响应加密算法和证书A
iPhone-&gt;MacBook Charles:https GET请求
MacBook Charles-&gt;MacBook Charles:按A 解密https请求
MacBook Charles-&gt;微信平台:https握手请求
微信平台--&gt;MacBook Charles:响应加密算法和证书B
MacBook Charles-&gt;微信平台:按B加密 https GET请求
微信平台--&gt;MacBook Charles:response
MacBook Charles-&gt;MacBook Charles:按B 解密response
MacBook Charles--&gt;iPhone:响应按A 加密response
iPhone-&gt;iPhone:按A解密response
</code></pre>

<p>经过上述的配置，我们已经可以读取到https的请求和响应数据了，如下图所示。</p>

<p><img src="media/15310632907202/15310659449947.jpg" alt=""/></p>

<blockquote>
<ul>
<li>windows下用findler可以实现相同的功能</li>
<li>其实这就是一个非常典型的中间人场景</li>
</ul>
</blockquote>

<h3 id="toc_5">数据接口</h3>

<p>接下来就根据这些数据来找出我们需要的接口了，经过分析，主要涉及三个接口</p>

<ul>
<li>获取用户信息接口</li>
<li>获取用户战绩列表接口</li>
<li>获取用户指定战绩详细信息接口</li>
</ul>

<p>下面我们一个一个看</p>

<h4 id="toc_6">1. 获取用户信息接口</h4>

<ul>
<li><p>request</p>

<table>
<thead>
<tr>
<th>API</th>
<th>/cgi-bin/gamewap/getpubgmdatacenterindex</th>
</tr>
</thead>

<tbody>
<tr>
<td>方法</td>
<td>GET</td>
</tr>
<tr>
<td>参数</td>
<td>openid、pass_ticket</td>
</tr>
<tr>
<td>cookie</td>
<td>key pass_ticket、uin、pgv_pvid、sd_cookie_crttime、sd_userid</td>
</tr>
</tbody>
</table></li>
<li><p>response</p>

<pre><code class="language-json">{
    &quot;user_info&quot;: {
        &quot;openid&quot;: &quot;oODfo0pjBQkcNuR4XLTQ321xFVws&quot;,
        &quot;head_img_url&quot;: &quot;http://wx.qlogo.cn/mmhead/Q3auHgzwzM5hSWxxxxxUQPwW9ibxxxx9DlxLTsKWk97oWpDI0rg/96&quot;,
        &quot;nick_name&quot;: &quot;望&quot;,
        &quot;role_name&quot;: &quot;xxxx&quot;,
        &quot;zone_area_id&quot;: 0,
        &quot;plat_id&quot;: 1
    },
    &quot;battle_info&quot;: {
        &quot;total_1&quot;: 75,
        &quot;total_10&quot;: 336,
        &quot;total_game&quot;: 745,
        &quot;total_kill&quot;: 1669
    },
    &quot;battle_list&quot;: [{
        &quot;map_id&quot;: 1,
        &quot;room_id&quot;: &quot;6575389198189071197&quot;,
        &quot;team_id&quot;: 57,
        &quot;dt_event_time&quot;: 1530953799,
        &quot;rank_in_ds&quot;: 3,
        &quot;times_kill&quot;: 1,
        &quot;label&quot;: &quot;前五&quot;,
        &quot;team_type&quot;: 1,
        &quot;award_gold&quot;: 677,
        &quot;mode&quot;: 0
    }],
    &quot;appitem&quot;: {
        &quot;AppID&quot;: &quot;wx13051697527efc45&quot;,
        &quot;IconURL&quot;: &quot;https://mmocgame.qpic.cn/wechatgame/mEMdfrX5RU0dZFfNEdCsMJpfsof1HE0TP3cfZiboX0ZPxqh5aZnHjxPFXUGgsXmibe/0&quot;,
        &quot;Name&quot;: &quot;绝地求生 全军出击&quot;,
        &quot;BriefName&quot;: &quot;绝地求生 全军出击&quot;,
        &quot;Desc&quot;: &quot;官方正版绝地求生手游&quot;,
        &quot;Brief&quot;: &quot;枪战 | 808.2M&quot;,
        &quot;WebURL&quot;: &quot;https://game.weixin.qq.com/cgi-bin/h5/static/detail_v2/index.html?wechat_pkgid=detail_v2&amp;appid=wx13051697527efc45&amp;show_bubble=0&quot;,
        &quot;DownloadInfo&quot;: {
            &quot;DownloadURL&quot;: &quot;https://itunes.apple.com/cn/app/id1304987143&quot;,
            &quot;DownloadFlag&quot;: 5
        },
        &quot;Status&quot;: 0,
        &quot;AppInfoFlag&quot;: 45,
        &quot;Label&quot;: [],
        &quot;AppStorePopUpDialogConfig&quot;: {
            &quot;Duration&quot;: 1500,
            &quot;Interval&quot;: 172800,
            &quot;ServerTimestamp&quot;: 1531066098
        },
        &quot;HasEnabledChatGroup&quot;: false,
        &quot;AppType&quot;: 0,
        &quot;game_tag_list&quot;: [&quot;绝地求生&quot;, &quot;正版还原&quot;, &quot;好友开黑&quot;, &quot;百人对战&quot;, &quot;超大地图&quot;],
        &quot;recommend_reason&quot;: &quot;正版绝地求生，荒野射击&quot;,
        &quot;size_desc&quot;: &quot;808.2M&quot;
    },
    &quot;is_guest&quot;: true,
    &quot;is_blocked&quot;: false,
    &quot;errcode&quot;: 0,
    &quot;errmsg&quot;: &quot;ok&quot;
}
</code></pre></li>
<li><p>分析</p>

<p>openid是用户的惟一标识。</p></li>
</ul>

<h4 id="toc_7">2. 获取用户战绩列表接口</h4>

<ul>
<li><p>request</p>

<table>
<thead>
<tr>
<th>API</th>
<th>/cgi-bin/gamewap/getpubgmbattlelist</th>
</tr>
</thead>

<tbody>
<tr>
<td>方法</td>
<td>GET</td>
</tr>
<tr>
<td>参数</td>
<td>openid、pass_ticket、plat_id、after_time、limit</td>
</tr>
<tr>
<td>cookie</td>
<td>key pass_ticket、uin、pgv_pvid、sd_cookie_crttime、sd_userid</td>
</tr>
</tbody>
</table></li>
<li><p>response</p>

<pre><code class="language-json">{
&quot;errcode&quot;: 0,
&quot;errmsg&quot;: &quot;ok&quot;,
&quot;next_after_time&quot;: 1528120556,
&quot;battle_list&quot;: [{
    &quot;map_id&quot;: 1,
    &quot;room_id&quot;: &quot;6575389198111172597&quot;,
    &quot;team_id&quot;: 57,
    &quot;dt_event_time&quot;: 1530953799,
    &quot;rank_in_ds&quot;: 3,
    &quot;times_kill&quot;: 1,
    &quot;label&quot;: &quot;前五&quot;,
    &quot;team_type&quot;: 1,
    &quot;award_gold&quot;: 677,
    &quot;mode&quot;: 0
}, {
    &quot;map_id&quot;: 1,
    &quot;room_id&quot;: &quot;6575336498940384115&quot;,
    &quot;team_id&quot;: 11,
    &quot;dt_event_time&quot;: 1530941404,
    &quot;rank_in_ds&quot;: 5,
    &quot;times_kill&quot;: 2,
    &quot;label&quot;: &quot;前五&quot;,
    &quot;team_type&quot;: 1,
    &quot;award_gold&quot;: 632,
    &quot;mode&quot;: 0
}],
&quot;has_next&quot;: true
}
</code></pre></li>
<li><p>分析</p>

<ul>
<li>这个接口用after_time来进行分页，遍历获取时可以根据接口响应的has_next和next_after_time来判断是否还有下一页的数据。</li>
<li>列表里面的room_id是每一场battle的惟一标识。</li>
</ul></li>
</ul>

<h4 id="toc_8">3. 获取用户战绩详情接口</h4>

<ul>
<li><p>request</p>

<table>
<thead>
<tr>
<th>API</th>
<th>/cgi-bin/gamewap/getpubgmbattledetail</th>
</tr>
</thead>

<tbody>
<tr>
<td>方法</td>
<td>GET</td>
</tr>
<tr>
<td>参数</td>
<td>openid、pass_ticket、room_id</td>
</tr>
<tr>
<td>cookie</td>
<td>key pass_ticket、uin、pgv_pvid、sd_cookie_crttime、sd_userid</td>
</tr>
</tbody>
</table></li>
<li><p>response</p>

<pre><code class="language-json">{
&quot;errcode&quot;: 0,
&quot;errmsg&quot;: &quot;ok&quot;,
&quot;base_info&quot;: {
    &quot;nick_name&quot;: &quot;柚茶&quot;,
    &quot;head_img_url&quot;: &quot;http://wx.qlogo.cn/mmhead/xxxx/96&quot;,
    &quot;dt_event_time&quot;: 1528648165,
    &quot;team_type&quot;: 4,
    &quot;rank&quot;: 1,
    &quot;player_count&quot;: 100,
    &quot;role_sex&quot;: 1,
    &quot;label&quot;: &quot;大吉大利&quot;,
    &quot;openid&quot;: &quot;oODfo0s1w5lWjmxxxxxgQkcCljXQ&quot;
},
&quot;battle_info&quot;: {
    &quot;award_gold&quot;: 622,
    &quot;times_kill&quot;: 6,
    &quot;times_head_shot&quot;: 0,
    &quot;damage&quot;: 537,
    &quot;times_assist&quot;: 3,
    &quot;survival_duration&quot;: 1629,
    &quot;times_save&quot;: 0,
    &quot;times_reborn&quot;: 0,
    &quot;vehicle_kill&quot;: 1,
    &quot;forward_distance&quot;: 10140,
    &quot;driving_distance&quot;: 5934,
    &quot;dead_poison_circle_no&quot;: 6,
    &quot;top_kill_distance&quot;: 223,
    &quot;top_kill_distance_weapon_use&quot;: 2924130819,
    &quot;be_kill_user&quot;: {
        &quot;nick_name&quot;: &quot;小旭&quot;,
        &quot;head_img_url&quot;: &quot;http://wx.qlogo.cn/mmhead/ibLButGMnqJNFsUtStNEV8tzlH1QpwPiaF9kxxxxx66G3ibjic6Ng2Rcg/96&quot;,
        &quot;weapon_use&quot;: 20101000001,
        &quot;openid&quot;: &quot;oODfo0qrPLExxxxc0QKjFPnPxyI&quot;
    },
    &quot;label&quot;: &quot;大吉大利&quot;
},
&quot;team_info&quot;: {
    &quot;user_list&quot;: [{
        &quot;nick_name&quot;: &quot;ooo&quot;,
        &quot;times_kill&quot;: 6,
        &quot;assist_count&quot;: 3,
        &quot;survival_duration&quot;: 1638,
        &quot;award_gold&quot;: 632,
        &quot;head_img_url&quot;: &quot;http://wx.qlogo.cn/mmhead/Q3auHgzwzM4k4RXdyxavNxxxxUjcX6Tl47MNNV1dZDliazRKRg&quot;,
        &quot;openid&quot;: &quot;oODfo0xxxxf1bRAXE-q-lEezK0k&quot;
    }, {
        &quot;nick_name&quot;: &quot;我吃炒肉&quot;,
        &quot;times_kill&quot;: 2,
        &quot;assist_count&quot;: 2,
        &quot;survival_duration&quot;: 1502,
        &quot;award_gold&quot;: 583,
        &quot;head_img_url&quot;: &quot;http://wx.qlogo.cn/mmhead/sTJptKvBQLKd5SAAjOF0VrwiapUxxxxFffxoDUcrVjYbDf9pNENQ&quot;,
        &quot;openid&quot;: &quot;oODfo0gIyDxxxxZpUrSrpapZSDT0&quot;
    }]
},
&quot;is_guest&quot;: true,
&quot;is_blocked&quot;: false
}
</code></pre></li>
<li><p>分析</p>

<ul>
<li>这个接口响应了战斗的详细信息，包括杀人数、爆头数、救人数、跑动距离等等，足够我们分析了。</li>
<li>这个接口还响应了是被谁杀死的以及组团成员的openid，利用这个特性我们这可无限深度的发散爬取更多用户的数据。</li>
</ul></li>
</ul>

<p>至于cookie中的息pass_ticket等信息肯定是用于权限认证的，在上述的几次请求中这些信息都没有变化，所以我们不需要深研其是怎么算出来的，只需要抓包提取到默认信息后填到代码里面就可以用了。</p>

<h2 id="toc_9">Step 2 爬取数据</h2>

<p>接口已经确定下来了，接下来就是去抓取足够量的数据了。</p>

<h3 id="toc_10">使用requests请求接口获取数据</h3>

<pre><code class="language-python">
    url = &#39;https://game.weixin.qq.com/cgi-bin/gamewap/getpubgmdatacenterindex?openid=%s&amp;plat_id=0&amp;uin=&amp;key=&amp;pass_ticket=%s&#39; % (openid, settings.pass_ticket)
    r = requests.get(url=url, cookies=settings.def_cookies, headers=settings.def_headers, timeout=(5.0, 5.0))
    tmp = r.json()
    wfile = os.path.join(settings.Res_UserInfo_Dir, &#39;%s.txt&#39; % (rediskeys.user(openid)))

    with codecs.open(wfile, &#39;w&#39;, &#39;utf-8&#39;) as wf:
        wf.write(simplejson.dumps(tmp, indent=2, sort_keys=True, ensure_ascii=False))

</code></pre>

<p>参照这种方式我们可以很快把另外两个接口写好。</p>

<h3 id="toc_11">使用redis来标记已经爬取过的信息</h3>

<p>在上述接口中我们可能从用户A的入口进去找到用户B的openid，然后从用户B的入口进去又找到用户A的openid，为了避免重复采集，所以我们需要记录下哪些信息是我们采集过的。</p>

<p>核心代码片断</p>

<pre><code class="language-python"># rediskeys.user_battle_list 根据openid获取存在redis中的key值
def user_battle_list(openid):
    return &#39;ubl_%s&#39; % (openid)
</code></pre>

<pre><code class="language-python"># 在提取battle list之前，首先判断这用用户的数据是否已经提取过了
if settings.DataRedis.get(rediskeys.user_battle_list(openid)):
        return True
</code></pre>

<pre><code class="language-python"># 在提取battle list之后，需要在redis中记录用户信息
settings.DataRedis.set(rediskeys.user_battle_list(openid), 1)
</code></pre>

<h3 id="toc_12">使用celery来管理队列</h3>

<p>celery是一个非常好用的分布式队列管理工具，我这次只打算在我自己的电脑上运行，所以并没有用到分布式的功能。</p>

<p>我们创建三个task和三个queue</p>

<pre><code class="language-python">task_queues = (
    Queue(&#39;queue_get_battle_info&#39;, exchange=Exchange(&#39;priority&#39;, type=&#39;direct&#39;), routing_key=&#39;gbi&#39;),
    Queue(&#39;queue_get_battle_list&#39;, exchange=Exchange(&#39;priority&#39;, type=&#39;direct&#39;), routing_key=&#39;gbl&#39;),
    Queue(&#39;queue_get_user_info&#39;, exchange=Exchange(&#39;priority&#39;, type=&#39;direct&#39;), routing_key=&#39;gui&#39;),
)

task_routes = ([
    (&#39;get_battle_info&#39;, {&#39;queue&#39;: &#39;queue_get_battle_info&#39;}),
    (&#39;get_battle_list&#39;, {&#39;queue&#39;: &#39;queue_get_battle_list&#39;}),
    (&#39;get_user_info&#39;, {&#39;queue&#39;: &#39;queue_get_user_info&#39;}),
],)
</code></pre>

<p>然后在task中控制API请求和Redis数据实现完整的任务逻辑，如：</p>

<pre><code class="language-python">@app.task(name=&#39;get_battle_list&#39;)
def get_battle_list(openid, plat_id=None, after_time=0, update_time=None):
    # 判断是否已经取过用户战绩列表信息
    if settings.DataRedis.get(rediskeys.user_battle_list(openid)):
        return True

    if not plat_id:
        try:
            # 提取用户信息
            us = handles.get_user_info_handles(openid)
            plat_id=us[&#39;plat_id&#39;]
        except Exception as e:
            print &#39;can not get user plat_id&#39;, openid, traceback.format_exc()
            return False
    # 提取战绩列表
    battle_list = handles.get_battle_list_handle(openid, plat_id, after_time=0, update_time=None)
    
    # 为每一场战斗创建异步获取详情任务
    for room_id in battle_list:
        if not settings.DataRedis.get(rediskeys.user_battle(openid, room_id)):
            get_battle_info.delay(openid, plat_id, room_id)

    return True
</code></pre>

<h3 id="toc_13">开始抓取</h3>

<p>因为我们是发散是爬虫，所以需要给代码一个用户的入口，所以需要手动创建一个用户的采集任务</p>

<pre><code class="language-python">from tasks.all import get_battle_list

my_openid = &#39;oODfo0oIErZI2xxx9xPlVyQbRPgY&#39;
my_platid = &#39;0&#39;

get_battle_list.delay(my_openid, my_platid, after_time=0, update_time=None)
</code></pre>

<p>有入口之后我们就用celery来启动worker去开始爬虫</p>

<pre><code class="language-bash"># 启动获取用户详情worker
celery -A tasks.all worker -c 5 --queue=queue_get_user_info --loglevel=info -n get_user_info@%h

# 启动获取战绩列表worker
celery -A tasks.all worker -c 5 --queue=queue_get_battle_list --loglevel=info -n get_battle_list@%h

# 启动获取战绩详情worker
celery -A tasks.all worker -c 30 --queue=queue_get_battle_info --loglevel=info -n get_battle_info@%h
</code></pre>

<p>这样我们的爬虫就可以愉快的跑起来了。再通过celery-flower来查看执行情况。</p>

<pre><code class="language-bash">celery flower -A tasks.all --broker=redis://:$REDIS_PASS@$REDIS_HOST:$REDIS_PORT/10
</code></pre>

<p>通过flower，我们可以看到运行的效率还是非常不错的。</p>

<p><img src="media/15310632907202/15308449650665.jpg" alt="15308449650665"/></p>

<p>在执行过程中会发现get_battle_list跑太快，导致get_battle_info即使开了30个并发都还会积压很多，所以需要适时的去停一下这些worker。</p>

<p>在我们抓到20万条信息之后就可以停下来了。</p>

<h2 id="toc_14">Step 3 数据分析</h2>

<h3 id="toc_15">分析方案</h3>

<p>20万场战斗的数据已经抓取好了，全部分成json文件存在我本地磁盘上，接下来就做一些简单的分析。</p>

<p>python在数据分析领域也非常强大，有很多非常优秀的库，如pandas和NumPy，可惜我都没有学过，而且对于一个高考数学只考了70几分的人来说，数据分析实在是难，所以就自己写了一个非常简单的程序来做一些浅度分析。</p>

<p>需要进行深度分析，又不想自己爬虫的大牛可以联系我打包这些数据。</p>

<pre><code class="language-python">
# coding=utf-8
import os
import json
import datetime
import math

from conf import settings


class UserTeamTypeData:
    def __init__(self, team_type, player_count):
        self.team_type = team_type
        self.player_count = player_count
        self.label = {}
        self.dead_poison_circle_no = {}
        self.count = 0
        self.damage = 0
        self.survival_duration = 0  # 生存时间
        self.driving_distance = 0
        self.forward_distance = 0
        self.times_assist = 0  # 助攻
        self.times_head_shot = 0
        self.times_kill = 0
        self.times_reborn = 0  # 被救次数
        self.times_save = 0  # 救人次数
        self.top_kill_distance = []
        self.top_kill_distance_weapon_use = {}
        self.vehicle_kill = 0  # 车辆杀死
        self.award_gold = 0
        self.times_reborn_by_role_sex = {0: 0, 1: 0}  # 0 男 1 女
        self.times_save_by_role_sex = {0: 0, 1: 0}  # 0 男 1 女

    def update_dead_poison_circle_no(self, dead_poison_circle_no):
        if dead_poison_circle_no in self.dead_poison_circle_no:
            self.dead_poison_circle_no[dead_poison_circle_no] += 1
        else:
            self.dead_poison_circle_no[dead_poison_circle_no] = 1

    def update_times_reborn_and_save_by_role_sex(self, role, times_reborn, times_save):
        if role not in self.times_reborn_by_role_sex:
            return

        self.times_reborn_by_role_sex[role] += times_reborn
        self.times_save_by_role_sex[role] += times_save

    def update_top_kill_distance_weapon_use(self, weaponid):
        if weaponid not in self.top_kill_distance_weapon_use:
            self.top_kill_distance_weapon_use[weaponid] = 1
        else:
            self.top_kill_distance_weapon_use[weaponid] += 1


class UserBattleData:

    def __init__(self, openid):
        self.openid = openid
        self.team_type_res = {}
        self.label = {}
        self.hour_counter = {}
        self.weekday_counter = {}
        self.usetime = 0
        self.day_record = set()
        self.battle_counter = 0

    def get_avg_use_time_per_day(self):
        # print &quot;get_avg_use_time_per_day:&quot;, self.openid, self.usetime, len(self.day_record), self.usetime / len(self.day_record)
        return self.usetime / len(self.day_record)

    def update_label(self, lable):
        if lable in self.label:
            self.label[lable] += 1
        else:
            self.label[lable] = 1

    def get_team_type_data(self, team_type, player_count):
        player_count = int(math.ceil(float(player_count) / 10))
        team_type_key = &#39;%d_%d&#39; % (team_type, player_count)

        if team_type_key not in self.team_type_res:
            userteamtypedata = UserTeamTypeData(team_type, player_count)
            self.team_type_res[team_type_key] = userteamtypedata
        else:
            userteamtypedata = self.team_type_res[team_type_key]

        return userteamtypedata

    def update_user_time_property(self, dt_event_time):
        dt_event_time = datetime.datetime.fromtimestamp(dt_event_time)
        hour = dt_event_time.hour
        if hour in self.hour_counter:
            self.hour_counter[hour] += 1
        else:
            self.hour_counter[hour] = 1

        weekday = dt_event_time.weekday()
        if weekday in self.weekday_counter:
            self.weekday_counter[weekday] += 1
        else:
            self.weekday_counter[weekday] = 1

        self.day_record.add(dt_event_time.date())

    def update_battle_info_by_room(self, roomid):
        # print &#39;  load &#39;, self.openid, roomid
        file = os.path.join(settings.Res_UserBattleInfo_Dir, self.openid, &#39;%s.txt&#39; % roomid)

        with open(file, &#39;r&#39;) as rf:
            battledata = json.load(rf)

        self.battle_counter += 1
        base_info = battledata[&#39;base_info&#39;]
        self.update_user_time_property(base_info[&#39;dt_event_time&#39;])
        battle_info = battledata[&#39;battle_info&#39;]

        userteamtypedata = self.get_team_type_data(base_info[&#39;team_type&#39;], base_info[&#39;player_count&#39;])
        userteamtypedata.count += 1
        userteamtypedata.award_gold += battle_info[&#39;award_gold&#39;]
        userteamtypedata.damage += battle_info[&#39;damage&#39;]
        userteamtypedata.update_dead_poison_circle_no(battle_info[&#39;dead_poison_circle_no&#39;])
        userteamtypedata.driving_distance += battle_info[&#39;driving_distance&#39;]
        userteamtypedata.forward_distance += battle_info[&#39;forward_distance&#39;]
        self.update_label(battle_info[&#39;label&#39;])
        userteamtypedata.survival_duration += battle_info[&#39;survival_duration&#39;]
        self.usetime += battle_info[&#39;survival_duration&#39;]/60
        userteamtypedata.times_assist += battle_info[&#39;times_assist&#39;]
        userteamtypedata.times_head_shot += battle_info[&#39;times_head_shot&#39;]
        userteamtypedata.times_kill += battle_info[&#39;times_kill&#39;]
        userteamtypedata.times_reborn += battle_info[&#39;times_reborn&#39;]
        userteamtypedata.times_save += battle_info[&#39;times_save&#39;]
        userteamtypedata.damage += battle_info[&#39;damage&#39;]
        userteamtypedata.top_kill_distance.append(battle_info[&#39;top_kill_distance&#39;])
        userteamtypedata.update_times_reborn_and_save_by_role_sex(base_info[&#39;role_sex&#39;], battle_info[&#39;times_reborn&#39;],
                                                                  battle_info[&#39;times_save&#39;])

    def get_user_battleinfo_rooms(self):
        user_dir = os.path.join(settings.Res_UserBattleInfo_Dir, self.openid)
        r = [room for room in os.listdir(user_dir)]
        r = [rr.replace(&#39;.txt&#39;, &#39;&#39;) for rr in r]
        return r

class AllUserCounter:

    def __init__(self):
        self.hour_counter = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0, 14: 0, 15: 0, 16: 0, 17: 0, 18: 0, 19: 0, 20: 0, 21: 0, 22: 0, 23: 0}

        self.weekday_counter = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0}
        self.times_reborn_by_role_sex = {0: 0, 1: 0}  # 0 男 1 女
        self.times_save_by_role_sex = {0: 0, 1: 0}  # 0 男 1 女
        self.user_count = 0
        self.battle_count = 0
        self.every_user_use_time_per_day = []
        self.top_kill_distance = 0

    def avg_use_time(self):
        return sum(self.every_user_use_time_per_day) / len(self.every_user_use_time_per_day)

    def add_user_data(self, userbattledata):
        self.every_user_use_time_per_day.append(userbattledata.get_avg_use_time_per_day())
        self.battle_count += userbattledata.battle_counter
        self.user_count += 1

        for k in userbattledata.hour_counter:
            if k in self.hour_counter:
                self.hour_counter[k] += userbattledata.hour_counter[k]
            else:
                self.hour_counter[k] = userbattledata.hour_counter[k]

        for weekday in userbattledata.weekday_counter:
            if weekday in self.weekday_counter:
                self.weekday_counter[weekday] += userbattledata.weekday_counter[weekday]
            else:
                self.weekday_counter[weekday] = userbattledata.weekday_counter[weekday]

        for userteamtype in userbattledata.team_type_res:
            userteamtypedata = userbattledata.team_type_res[userteamtype]
            for k in userteamtypedata.times_reborn_by_role_sex:
                self.times_reborn_by_role_sex[k] += userteamtypedata.times_reborn_by_role_sex[k]

            for k in userteamtypedata.times_save_by_role_sex:
                self.times_save_by_role_sex[k] += userteamtypedata.times_save_by_role_sex[k]

            if userteamtypedata.top_kill_distance &gt; self.top_kill_distance:
                self.top_kill_distance = userteamtypedata.top_kill_distance

    def __str__(self):
        res = []
        res.append(&#39;总用户数\t%d&#39; % self.user_count)
        res.append(&#39;总战斗数\t%d&#39; % self.battle_count)
        res.append(&#39;平均日耗时\t%d&#39; % self.avg_use_time())
        res.append(&#39;最远击杀\t%d&#39; % max(self.top_kill_distance))
        res.append(&#39;男性角色\t被救%d次\t救人%d次&#39; % (self.times_reborn_by_role_sex[0], self.times_save_by_role_sex[0]))
        res.append(&#39;女性角色\t被救%d次\t救人%d次&#39; % (self.times_reborn_by_role_sex[1], self.times_save_by_role_sex[1]))

        res.append(&#39;小时分布&#39;)
        for hour in range(0, 24):
            # res.append(&#39;\t%d: %d&#39; % (hour, self.hour_counter[hour]))
            res.append(&#39;\t%d: %d %.2f%%&#39; % (hour, self.hour_counter[hour], self.hour_counter[hour]/float(self.battle_count)*100))
        res.append(&#39;星期分布&#39;)
        # res.append(self.weekday_counter.__str__())
        for weekday in range(0, 7):
            res.append(&#39;\t%d: %d %.2f%%&#39; % (weekday+1, self.weekday_counter[weekday], (self.weekday_counter[weekday]/float(self.battle_count)*100)))

        return &#39;\n&#39;.join(res)


def get_user_battleinfo_rooms(openid):
    user_dir = os.path.join(settings.Res_UserBattleInfo_Dir, openid)

    # files = os.listdir(user_dir)
    r = [room for room in os.listdir(user_dir)]
    r = [rr.replace(&#39;.txt&#39;, &#39;&#39;) for rr in r]
    return r


if __name__ == &#39;__main__&#39;:
    alluserconter = AllUserCounter()
    
    folders = os.listdir(settings.Res_UserBattleInfo_Dir)
    i = 0
    for folder in folders:
        i+=1
        print i, &#39;/&#39; , len(folders), folder
        userbattledata = UserBattleData(folder)
        for room in userbattledata.get_user_battleinfo_rooms():
            userbattledata.update_battle_info_by_room(room)
        alluserconter.add_user_data(userbattledata)

    print &quot;\n&quot; * 3
    print &quot;---------------------------------------&quot;

    print alluserconter
</code></pre>

<h3 id="toc_16">分析结果</h3>

<h4 id="toc_17">1. 平均用户日在线时长2小时</h4>

<p><img src="media/15310632907202/15311020770066.jpg" alt=""/></p>

<p>从分布图上看大部分用户都在1小时以上，最猛的几个人超过8小时。</p>

<blockquote>
<p>注：我这里统计的是每一局的存活时间，实际在线时长会比我这个更长。</p>
</blockquote>

<h4 id="toc_18">2. 女性角色被救次数高于男性</h4>

<p><img src="media/15310632907202/15311012585793.jpg" alt=""/></p>

<p>终于知道为什么有那么多人妖了，原来在游戏里面可以占便宜啊。</p>

<h4 id="toc_19">3. 女性角色救人次数高于男性</h4>

<p><img src="media/15310632907202/15311012987492.jpg" alt=""/></p>

<p>给了大家一个带妹上分的好理由。</p>

<h4 id="toc_20">4. 周五大家最忙</h4>

<p><img src="media/15310632907202/15310699545478.jpg" alt=""/></p>

<p>估计周五大家都要忙着交差和写周报了。</p>

<h4 id="toc_21">5. 晚上22点是游戏高峰</h4>

<p><img src="media/15310632907202/15311024917841.jpg" alt=""/></p>

<p>凌晨还有那么多人玩，你们不睡觉吗？</p>

<h4 id="toc_22">6. 最远击杀距离639米</h4>

<p>我看了一下98K、SKS和AWP的有效射程，大致都在800米以内，所以这个值可信度还是可以的。</p>

<p>反过来看抖音上的那些超远距离击杀应该都是摆拍的。</p>

<h4 id="toc_23">7. 能拿到 救死扶伤 称号才是最高荣耀</h4>

<p><img src="media/15310632907202/15311041446783.jpg" alt=""/></p>

<p>从分布情况可以看出来，救死扶伤比十杀还要难。</p>

<p><img src="media/15310632907202/15311063423105.jpg" alt=""/><br/>
能拿到救死扶伤称号的大部分都是女性角色，再一次证明玩游戏要带妹。</p>

<p>回归到这个游戏的本质，那就是生存游戏，没什么比活下来更重要的了。</p>

<h2 id="toc_24">结尾</h2>

<p>这次爬虫主要是利用了微信游戏频道可以查看陌生人数据的场景才能提取到这么多数据。我们可以通过同样的手段来分析王者荣耀和其它游戏的数据，有兴趣的同学可以尝试一下。</p>

<p>最后再说一下，UMP9是把好枪，配2倍镜非常爽。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于12' MacBook使用的记录]]></title>
    <link href="blog.codingroad.com/why-choose-macbook.html"/>
    <updated>2018-04-24T15:03:46+08:00</updated>
    <id>blog.codingroad.com/why-choose-macbook.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">选择MacBook的原因</a>
<ul>
<li>
<a href="#toc_1">背景</a>
</li>
<li>
<a href="#toc_2">使用场景分析</a>
</li>
<li>
<a href="#toc_3">选择</a>
<ul>
<li>
<a href="#toc_4">1. Surface Pro 4</a>
</li>
<li>
<a href="#toc_5">2. iPad Pro</a>
</li>
<li>
<a href="#toc_6">3. MacBook</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_7">性能实测</a>
<ul>
<li>
<a href="#toc_8">1、40个worker并发爬虫</a>
</li>
<li>
<a href="#toc_9">2、日常工作场景</a>
</li>
<li>
<a href="#toc_10">3、Selenium + 15个Chrome并发任务</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">常用软件推荐</a>
<ul>
<li>
<a href="#toc_12">1、MWeb 专业的 Markdown 写作、记笔记、静态博客生成软件</a>
</li>
<li>
<a href="#toc_13">2、SecureCRT 专业的 Markdown 写作</a>
</li>
<li>
<a href="#toc_14">3、Charles 协议层代理抓包工具</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">选择MacBook的原因</h2>

<h3 id="toc_1">背景</h3>

<p>2017年底的时候因为爱人在老家待产，实在受不了背着沉重的2015版15寸MacBook Pro两头跑，所以打算买一台轻便的电脑。</p>

<h3 id="toc_2">使用场景分析</h3>

<p>可能是因为做了太久运维，养成了背着电脑出门的习惯，哪怕是去KTV或者去逛街都要背上电脑才觉得心安，这样有紧急问题时可以随时打开电脑和手机热点上线处理。现在不做运维好几年了，但是这个毛病还是改不掉了。</p>

<p>目前的工作中使用电脑的主要场景就是通过SecureCRT管理云服务器，用PyCharm写python的脚本或者web网站，本地需要搭建MySQL和Redis的服务做开发环境，偶尔看看Java项目的代码，但本地不会编译和运行。游戏从来也不玩，电影最多只用腾讯视频看看在线的。也就是说我对电脑性能的要求其实并不高，准确的说是非常低，而且本身就有一台15寸的MacBook Pro，可以在需要性能的时候使用。</p>

<p>所以这次买新电脑的主要的目标就是极致轻薄。</p>

<h3 id="toc_3">选择</h3>

<p>当时有三个选择：Surface Pro 4、iPad Pro和MacBook，经过对比分析后，最终在一次喝得快醉的时候入手了MacBook。下面说一下从我的角度对这三台设备的分析，性能参数什么的我就不罗列了，直接说要点。</p>

<blockquote>
<p>申明以下内容只是从我的经验和结合我的实际需求来分析，不喜勿喷</p>
</blockquote>

<h4 id="toc_4">1. Surface Pro 4</h4>

<p><img src="media/15245534266604/15245553140370.jpg" alt="" style="width:221px;"/><br/>
微软在笔记本领域经过前面几代Surface的大胆尝试之后，推出的性能和工业水平都非常高的产品。</p>

<p>对我来说有以下几个优点：</p>

<ul>
<li>Windows系统支持的软件广，虽说OSX平台上这些年软件也越来越多，但是还是无法和windows的软件生态比。</li>
<li>接口齐全，支持usb和sd卡。</li>
<li>支持平板和笔记本两种形态，不工作时候把键盘拆掉就可以当平板玩，玩游戏和看电影比较爽。</li>
</ul>

<p>对我来说有几个不足和疑虑：</p>

<ul>
<li>和已有的MacBook Pro文件同步不方便。键盘使用习惯也不同，比如复制操作 windows上用的是Control+C，而mac上用的是Command+C，如果两台混用估计会有大量的误操作。</li>
<li>因为osx和linux的相似性，在项目中广泛使用了环境变量来定义环境或者特殊变量，在一些脚本中会直接引用awk等命令，如果切换到windows上会非常不方便本地测试。</li>
<li>从论坛上还有以前的领导的使用经验来看，Surface存在无缘无故蓝屏的硬伤，原因未知。领导说换个输入法会好一些，但我不解，为什么输入法会导致电脑蓝屏。</li>
</ul>

<h4 id="toc_5">2. iPad Pro</h4>

<p><img src="media/15245534266604/15245551875358.jpg" alt="" style="width:243px;"/></p>

<p>apple一直想进一步占有生产力工具的份额，iPad Pro是娱乐工龄和生产力工具的混合体，有10.5寸和12.9寸两个选择，在酷动都体验过。</p>

<p>优点</p>

<ul>
<li>办公娱乐两不误， 前面说平板模式下的娱乐体验肯定比Surface强，因为ios平台下的游戏数量和质量比Surface多太多了（指可以触屏玩的游戏）。</li>
<li>可以通过iCloud与MBP进行文件同步。</li>
<li>已经有IDE和SSH工具来对应我的办公使用场景。</li>
<li>够轻，够逼格。</li>
</ul>

<p>不足</p>

<ul>
<li>debug代码不方便，虽然可以通过git将代码上传到云服务器上进行debug，但是这种操作肯定太不方便了。</li>
<li>没有鼠标，一边敲键盘一边还要伸手去屏幕上去点来点去的，体验非常差。</li>
</ul>

<h4 id="toc_6">3. MacBook</h4>

<p><img src="media/15245534266604/15245552489274.jpg" alt=""/></p>

<p>我买的时候apple称其为 New MacBook，主要是相对于第一代产品来说的。我看了一下，网上对它的诟病主要有以下两个点</p>

<ul>
<li><p>第一代的CPU性能确实不行，虽然New MacBook对CPU进行了升级，但是很多人还是不敢尝试的。<br/>
<img src="media/15245534266604/15245576307636.jpg" alt=""/></p></li>
<li><p>只有一个USB-C接口和一个3.5耳机接口，一定要买一个转换器才能满足基本的办公需要，而官方的转换器又超级贵。</p></li>
</ul>

<p>对我的使用场景来说，它有以下几个优点：</p>

<ul>
<li>性能其实是够用的，SecureCRT非常省资源，PyCharm可能会难一点，但是可以用Sublime进行替代，问题不大。</li>
<li>我日常仅需要一个hdmi接口带显示器，移动硬盘和U盘基本不用，所以只需要花一百多去小米买一根转接头就可以解决接口少的问题了。</li>
<li>轻：iPad和surface说很轻，但是键盘的重量加上之后就不一定比MacBook轻了。</li>
<li>与MBP的环境和使用习惯完全一致，不存在使用障碍。</li>
</ul>

<h2 id="toc_7">性能实测</h2>

<h3 id="toc_8">1、40个worker并发爬虫</h3>

<p>在做 <a href="http://python.jobbole.com/89209/">用 Python 分析了 20 万场吃鸡数据</a> 分析时，在单机上开了30个并发去抓取腾讯游戏的数据， 从flower中拿到的TPS性能图如下：</p>

<p><img src="media/15245534266604/15308449650665.jpg" alt=""/><br/>
可以看出峰值可以超过200，而且在整个爬取过程中，在PyCharm中操作丝毫不会觉得卡。</p>

<p>后续我想了一下，因为我用的是wifi，可能wifi的带宽瓶颈才是限制TPS的主要原因。</p>

<h3 id="toc_9">2、日常工作场景</h3>

<p>在日常工作时我经常会同时打开以下APP：</p>

<ul>
<li>2-3个PyCharm</li>
<li>一个Chrome进程，5-6个tab</li>
<li>Sublime</li>
<li>QQ、WeiXin</li>
<li>SecureCRT</li>
<li>MySQL服务</li>
<li>Redis服务</li>
<li>FileZilla</li>
<li>酸酸乳</li>
</ul>

<p>以上同时打开，工作依然丝般顺滑。</p>

<h3 id="toc_10">3、Selenium + 15个Chrome并发任务</h3>

<p>有一次有一个临时任务，需要通过浏览器去登陆不同的用户进行业务操作，使用Selenium同时打开20个Chrome进程进行操作的时候，系统开始觉得有些吃力了。可能Chrome太占内存了。用15个并发的时候就觉得还好了。</p>

<p>所以MacBook的性能对日常工作来说完全是够用的，普通的文档工作，简单上上网什么的更不用说了。</p>

<h2 id="toc_11">常用软件推荐</h2>

<h3 id="toc_12">1、MWeb 专业的 Markdown 写作、记笔记、静态博客生成软件</h3>

<p><a href="https://zh.mweb.im/index.html">MWeb</a></p>

<p>差不多是我惟一在AppStore上买的付费软件了，虽然有破解版，但是我觉得优秀的国产软件还是要支持的。</p>

<p>本文就是使用MWeb写成的，最特色的功能点介绍：</p>

<ul>
<li>MarkDown优秀的解析和渲染</li>
<li>图片直接cmd+v就可以复制进文档</li>
<li>可以一键生成静态站点，可增加自定义模版代码接入统计和评论功能</li>
<li>可以把MarkDown文件导出成html、pdf、doc等格式</li>
</ul>

<p><img src="media/15245534266604/15314582182482.jpg" alt=""/></p>

<h3 id="toc_13">2、SecureCRT 专业的 Markdown 写作</h3>

<p><a href="https://www.vandyke.com/products/securecrt/">SecureCRT</a> 最专业的SSH工具之一，很早以前就开始用了，最特色的功能就是可以同时向所有打开的SSH窗口发送命令实现批量操作。</p>

<p><img src="media/15245534266604/15314583857253.jpg" alt=""/></p>

<h3 id="toc_14">3、Charles 协议层代理抓包工具</h3>

<p><a href="https://www.charlesproxy.com/">Charles</a> 的功能和Windows下的Fiddler相似，可以通过代理服务方式将协议层的信息抓出来，方便定位问题。</p>

<p>在做 <a href="http://python.jobbole.com/89209/">用 Python 分析了 20 万场吃鸡数据</a> 分析时，就使用Charles抓取了手机的流量进行接口分析。</p>

<p><img src="media/15310632907202/15310659449947.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL中文乱码]]></title>
    <link href="blog.codingroad.com/python-mysql-charset.html"/>
    <updated>2017-01-15T19:19:37+08:00</updated>
    <id>blog.codingroad.com/python-mysql-charset.html</id>
    <content type="html"><![CDATA[
<p>在连接时加上utf-8即可解决</p>

<pre><code class="language-python">
    def connect(self):
        if self.connected:
            return True

        try:
            self.logger.info(&quot;Get MySQL Connection, DB=%s&quot; % self.dbname)
            self._mysql = MySQLdb.connect(self.ip,
                                          self.username,
                                          self.password,
                                          self.db,
                                          port=self.port,
                                          local_infile=1,
                                          charset=&#39;utf8&#39;)
            self.connected = True
            self.logger.info(&quot;Get MySQL Connection Success, DB=%s&quot; % self.dbname)
            return True
        except Exception as e:
            self.logger.error(&quot;Get MySQL Connection Failed, DB=%s, Error=%s&quot; % (self.dbname, e.__str__()))
            return False
</code></pre>

<pre><code class="language-html">&lt;div class=&quot;ds-thread&quot; &gt;&lt;/div&gt;
&lt;!-- 多说评论框 end --&gt;
&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var duoshuoQuery = {short_name:&quot;codingroad&quot;};
    (function() {
        var ds = document.createElement(&#39;script&#39;);
        ds.type = &#39;text/javascript&#39;;ds.async = true;
        ds.src = (document.location.protocol == &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;//static.duoshuo.com/embed.js&#39;;
        ds.charset = &#39;UTF-8&#39;;
        (document.getElementsByTagName(&#39;head&#39;)[0] 
         || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds);
    })();
    &lt;/script&gt;
&lt;!-- 多说公共JS代码 end --&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTPS]]></title>
    <link href="blog.codingroad.com/om-ssl-config.html"/>
    <updated>2017-02-06T09:06:41+08:00</updated>
    <id>blog.codingroad.com/om-ssl-config.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">配置自签发证书</h2>

<ol>
<li><p>运行如下命令，生成keystore文件</p>

<pre><code> keytool -genkey -alias tomcat -keyalg RSA
</code></pre>

<p>这样就可以在用户家目录下生成一个.keystore文件。在生成过程中需要设置一些必要的信息，其中密码信息一定要记住。</p></li>
<li><p>修改server.xml，配置证书。</p>

<p>找到如下配置部分</p>

<pre><code class="language-xml"> &lt;!--
&lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot;
    maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
    clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; /&gt;
--&gt;
</code></pre>

<p>取消注释，修改成如下内容</p>

<pre><code class="language-xml"> &lt;Connector SSLEnabled=&quot;true&quot; 
            acceptCount=&quot;100&quot; 
            clientAuth=&quot;false&quot;
            disableUploadTimeout=&quot;true&quot;         
            enableLookups=&quot;false&quot;
            maxThreads=&quot;25&quot;
            port=&quot;8443&quot; 
            keystoreFile=&quot;~/.keystore&quot;
            keystorePass=&quot;password&quot;
            protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; 
            scheme=&quot;https&quot;
            secure=&quot;true&quot; 
            sslProtocol=&quot;TLS&quot; 
 /&gt;
</code></pre>

<blockquote>
<p>注： password请设置成上一步输入的密码</p>
</blockquote></li>
<li><p>重启apache-tomcat，访问 <code>https://localhost:8443</code> 查看效果。</p></li>
</ol>

<h2 id="toc_1">根据url配置https</h2>

<p>编辑web.xml文件</p>

<ol>
<li><p>设置所有路径都走https</p>

<pre><code class="language-xml">    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;HTTPSOnly&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;user-data-constraint&gt;
            &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
        &lt;/user-data-constraint&gt;
    &lt;/security-constraint&gt;
</code></pre></li>
<li><p>设置部分路径走https</p>

<pre><code class="language-xml">    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;HTTPSOnly&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;user-data-constraint&gt;
            &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
        &lt;/user-data-constraint&gt;
    &lt;/security-constraint&gt;
    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;HTTPSOrHTTP&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;*.ico&lt;/url-pattern&gt;
            &lt;url-pattern&gt;/img/*&lt;/url-pattern&gt;
            &lt;url-pattern&gt;/css/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;user-data-constraint&gt;
            &lt;transport-guarantee&gt;NONE&lt;/transport-guarantee&gt;
        &lt;/user-data-constraint&gt;
    &lt;/security-constraint&gt;

</code></pre></li>
</ol>

<h2 id="toc_2">生成cer证书文件</h2>

<ol>
<li><p>查看keystore信息</p>

<pre><code class="language-shell"> april@client:~$ keytool -list -v -keystore .keystore -storepass 123456
Keystore type: JKS
Keystore provider: SUN
Your keystore contains 1 entry
Alias name: tomcat
Creation date: Jan 16, 2017
Entry type: PrivateKeyEntry
Certificate chain length: 1
Certificate[1]:
Owner: CN=Z, OU=4YT, O=Unknown, L=hz, ST=zj, C=CN
Issuer: CN=Z, OU=4YT, O=Unknown, L=hz, ST=zj, C=CN
Serial number: 1822278c
Valid from: Mon Jan 16 16:44:46 CST 2017 until: Sun Apr 16 16:44:46 CST 2017
Certificate fingerprints:
         MD5:  14:6B:D9:2B:90:D7:AA:E7:5A:CC:8E:9A:A1:FD:0E:7B
</code></pre>

<p>可以看到我们需要导出的证书alias=tomcat</p></li>
<li><p>生成cer文件</p>

<pre><code class="language-shell">april@client:~$   keytool -export -alias tomcat -keystore .keystore -storepass 123456 -rfc -file client.cer
Certificate stored in file &lt;client.cer&gt;
</code></pre>

<p>这样我们就生成了一个cer文件，可以内置到app中，实现app开启https访问。</p></li>
</ol>

<h1 id="toc_3"></h1>

<p><a href="https://www.oschina.net/question/12_23148">参考链接：5分钟内搞定Tomcat的SSL配置</a><br/>
<a href="http://tomcat.apache.org/tomcat-7.0-doc/ssl-howto.html">参考链接：SSL/TLS Configuration HOW-TO</a><br/>
<a href="https://www.mulesoft.com/tcat/tomcat-ssl">参考链接：A Simple Step-By-Step Guide To Apache Tomcat SSL Configuration</a><br/>
<a href="http://www.itworld.com/article/2769041/development/how-to-configure-tomcat-to-always-require-https.html">参考链接：How to configure Tomcat to always require HTTPS</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OSS]]></title>
    <link href="blog.codingroad.com/om-aliyun-use-oss-as-nas.html"/>
    <updated>2017-02-06T22:52:50+08:00</updated>
    <id>blog.codingroad.com/om-aliyun-use-oss-as-nas.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">通过oss实现共享存储</a>
<ul>
<li>
<a href="#toc_1">需求</a>
</li>
<li>
<a href="#toc_2">安装</a>
</li>
<li>
<a href="#toc_3">配置</a>
</li>
<li>
<a href="#toc_4">取消映射</a>
</li>
<li>
<a href="#toc_5">参考链接</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">数据异地灾备</a>
<ul>
<li>
<a href="#toc_7">需求</a>
</li>
<li>
<a href="#toc_8">参考链接</a>
</li>
</ul>
</li>
</ul>


<hr/>

<h2 id="toc_0">通过oss实现共享存储</h2>

<h3 id="toc_1">需求</h3>

<p>接入层的www门户、H5门户和APP门户都需要使用到同一份内容文件，这些文件的业务特点是：</p>

<ul>
<li>不会出现并发写，如用户头像，一般情况下只会出现单个请求来修改</li>
<li>读的次数远大于写的次数。</li>
<li>读取和写入时有明确的文件名和路径，不会用取文件列表的操作和find操作。</li>
</ul>

<p>由于该需求出现的时候，还没有NAS服务，经过研究发现可以使用阿里开源项目ossfs将oss挂载成本地目录，以实现这个需求，具体操作如下：</p>

<h3 id="toc_2">安装</h3>

<pre><code class="language-shell">root@iZ2590mt68kZ:~# apt-get install gdebi-core
root@iZ2590mt68kZ:~# wget https://github.com/aliyun/ossfs/releases/download/v1.79.9/ossfs_1.79.9_ubuntu14.04_amd64.deb
root@iZ2590mt68kZ:~# gdebi ossfs_1.79.9_ubuntu14.04_amd64.deb
</code></pre>

<h3 id="toc_3">配置</h3>

<pre><code class="language-shell">h5@iZ2590mt68kZ:~$ echo &quot;sharedata:KradSx13tE012346:h0FgmWo775ksae8n171opZg2512345&quot; &gt; ~/.passwd-ossfs
h5@iZ2590mt68kZ:~$ chmod 640 ~/.passwd-ossfs
```ca

说明：

    
| 值 | 说明 |
| --- | --- |
| sharedata | BucketName |
| KradSx13tE012346 | Access Key ID |
| h0FgmWo775ksae8n171opZg2512345 | Access Key Secret |

### 映射本地目录

```shell
h5@iZ2590mt68kZ:~$ mkdir /home/april/sharedata
h5@iZ2590mt68kZ:~$ ossfs sharedata /home/april/sharedata -ourl=http://oss-cn-beijing-internal.aliyuncs.com
</code></pre>

<p>这样就Bucket名为sharedata的oss存储映射到本地/home/april/sharedata目录了。</p>

<blockquote>
<p>注：ourl为你的oss所在域的域名，在控制台中可以看到，将bucketname去掉就可以了<br/>
由于我的ECS和oss是在同一个区，为了节约流量钱，我就直接用内网域名。</p>
</blockquote>

<h3 id="toc_4">取消映射</h3>

<pre><code class="language-shell">h5@iZ2590mt68kZ:~$ fusermount -u /home/april/sharedata
</code></pre>

<h3 id="toc_5">参考链接</h3>

<ul>
<li><a href="https://github.com/aliyun/ossfs">ossfs项目首页</a></li>
</ul>

<h2 id="toc_6">数据异地灾备</h2>

<h3 id="toc_7">需求</h3>

<p>我们将帖子的内容文件存在oss上，由于oss的特性，取指定文件非常快，但是遍历文件就会非常慢，所以在ECS上进行文件备份是一个大难题。</p>

<p>经过研究发现阿里云本身提供oss跨域备份的功能，可以很轻松的实现这个需求。</p>

<p><img src="media/14863927703729/14864321364035.jpg" alt=""/></p>

<h3 id="toc_8">参考链接</h3>

<ul>
<li><a href="https://help.aliyun.com/document_detail/31864.html">oss管理跨区域复制</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python xml操作]]></title>
    <link href="blog.codingroad.com/python-xml.html"/>
    <updated>2017-02-15T13:51:29+08:00</updated>
    <id>blog.codingroad.com/python-xml.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">生成xml数据</a>
</li>
<li>
<a href="#toc_1">增加文本节点</a>
</li>
</ul>


<hr/>

<h2 id="toc_0">生成xml数据</h2>

<pre><code class="language-python">from xml.dom.minidom import Document
doc = Document()
chapterinfo = doc.createElement(&#39;chapterinfo&#39;)
doc.appendChild(chapterinfo)

bookid = doc.createElement(&#39;bookid&#39;)
title_text = doc.createCDATASection(&#39;12333&#39;)

bookid.appendChild(title_text)
chapterinfo.appendChild(bookid)
    
print doc.toxml(&#39;utf-8&#39;)
</code></pre>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;chapterinfo&gt;
    &lt;bookid&gt;
        &lt;![CDATA[12333]]&gt;
    &lt;/bookid&gt;
&lt;/chapterinfo&gt;
</code></pre>

<h2 id="toc_1">增加文本节点</h2>

<pre><code class="language-python"># coding=utf-8
from xml.dom.minidom import Document

# 增加Cdata节点
def appendCdataNode(xmlobj, title, text):
    doc = Document()
    tmp = doc.createElement(title)
    text = str2unicode(text)
    tmp_txt = doc.createCDATASection(text)
    tmp.appendChild(tmp_txt)
    xmlobj.appendChild(tmp)

# 增加普通text节点
def appendTextNode(xmlobj, title, text):
    doc = Document()
    tmp = doc.createElement(title)
    if not isinstance(text, str):
        try:
            text = str(text)
        except Exception as e:
            print e
            return
    text = str2unicode(text)
    tmp_txt = doc.createTextNode(text)
    tmp.appendChild(tmp_txt)
    xmlobj.appendChild(tmp)

# str转成unicode，避免在组装xml对象时出错
def str2unicode(text):
    if type(text) == str:
        return text.decode(&#39;utf-8&#39;)
    elif type(text) == unicode:
        return text
    else:
        print &quot;str2unicode failed, text type is not str or unicode, type=%s&quot; % type(text)
        return None

# 测试代码
if __name__ == &#39;__main__&#39;:
    doc = Document()
    book = doc.createElement(&#39;book&#39;)
    appendTextNode(book, &quot;bookname&quot;, &quot;热&quot;)
    appendTextNode(book, &quot;viewcount&quot;, 10003)
    appendCdataNode(book, &quot;description&quot;, &quot;这不是一本黄书&quot;)
    doc.appendChild(book)
    
    print doc.toprettyxml()

</code></pre>

<p>结果</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;book&gt;
    &lt;bookname&gt;热&lt;/bookname&gt;
    &lt;viewcount&gt;10003&lt;/viewcount&gt;
    &lt;description&gt;&lt;![CDATA[这不是一本黄书]]&gt;&lt;/description&gt;
&lt;/book&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python ip操作]]></title>
    <link href="blog.codingroad.com/python-ip.html"/>
    <updated>2017-02-15T13:55:19+08:00</updated>
    <id>blog.codingroad.com/python-ip.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">根据ip段取所有ip</a>
</li>
<li>
<a href="#toc_1">计算ip是否在指定的段中</a>
</li>
<li>
<a href="#toc_2">django校验来源ip是否在配置的白名单中</a>
</li>
</ul>


<h2 id="toc_0">根据ip段取所有ip</h2>

<pre><code class="language-python">from IPy import IP
ip = IP(&#39;192.168.0.0/24&#39;)
print ip.len()

for i in ip:
   print i
</code></pre>

<h2 id="toc_1">计算ip是否在指定的段中</h2>

<pre><code class="language-python">from IPy import IP
ip = IP(&#39;192.168.0.0/24&#39;)
print IP(&#39;192.168.0.132&#39;) in ip
</code></pre>

<h2 id="toc_2">django校验来源ip是否在配置的白名单中</h2>

<pre><code class="language-python">
iplist = &quot;&quot;&quot;192.168.1.0/24
192.168.1.64/26
10.0.1.0/25
127.0.0.1&quot;&quot;&quot;

# 加载ip列表，本算法是应对配置的ip量较大的情况
# 将ip的A\B\C段做为key，ip做为value，生成一个dict，提升校验速度
# {
#   &#39;192.168.1&#39;: [IP(&#39;192.168.1.2&#39;), 
#                 IP(&#39;192.168.1.3&#39;), 
#                 IP(&#39;192.168.1.4&#39;)]
#   &#39;127.0.0&#39;: [IP(&#39;127.0.0.1&#39;)]
# }
def loadip():
    res = {}
    for ipstring in iplist.split(&quot;\n&quot;):
        # 提取ip的ABC段
        key = &#39;.&#39;.join(ipstring.split(&#39;.&#39;)[:3])
        if key not in res:
            res[key] = []

        ips = IP(ipstring)
        for ip in ips:
            # print ip
            res[key].append(ip)

    return res

# 校验request是否是合法来源
def _check_request(request):
    ipwhitelist = loadip()
    remoteip = request.META[&#39;REMOTE_ADDR&#39;]
    key = &#39;.&#39;.join(remoteip.split(&quot;.&quot;)[:3])
    remoteip = IP(remoteip)

    if key not in ipwhitelist:
        return False

    if remoteip not in ipwhitelist[key]:
        return False
    return True

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python 在__init__中批量设置类属性]]></title>
    <link href="blog.codingroad.com/python-set-class-attr-in-init.html"/>
    <updated>2017-02-16T08:45:41+08:00</updated>
    <id>blog.codingroad.com/python-set-class-attr-in-init.html</id>
    <content type="html"><![CDATA[
<p>常见的写法：</p>

<pre><code class="language-python">def __init__(self, x, y, z):
    ...
    self.x = x
    self.y = y
    self.z = z
    ...
</code></pre>

<p>可以简写成如下：</p>

<pre><code class="language-python">class A:
    def __init__(self, **kwargs):
        for key in kwargs:
            setattr(self, key, kwargs[key])
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python 项目开发技巧 - 配置与代码分离]]></title>
    <link href="blog.codingroad.com/python-config-in-different-env.html"/>
    <updated>2017-03-20T22:18:51+08:00</updated>
    <id>blog.codingroad.com/python-config-in-different-env.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">问题</a>
</li>
<li>
<a href="#toc_1">解决方案</a>
</li>
<li>
<a href="#toc_2">示例</a>
</li>
</ul>


<hr/>

<h2 id="toc_0">问题</h2>

<p>写项目代码的时候，在配置上容易碰到下面三个问题：</p>

<ol>
<li>多个环境之间存在多套配置，发布时需要单独处理配置信息。</li>
<li>配置中存在敏感信息，如数据库连接串，开源代码时需要修改配置。</li>
<li>同一台主机上运行多个项目，但都使用到同一个配置，一但发生变更，需要修改多个项目的代码。</li>
</ol>

<h2 id="toc_1">解决方案</h2>

<p>针对以上两个问题，在《Flask Web开发》 <code>Miguel Grinberg</code>中找到的解决方案：</p>

<pre><code>  使用环境变量来存储关键配置，或者主机相关环境配置信息
</code></pre>

<h2 id="toc_2">示例</h2>

<p>如，针对问题1，我们可以按如下步骤解决：</p>

<ol>
<li><p>在开发主机上设置环境变量</p>

<pre><code class="language-shell">QindeMacBook-Pro-2:~ echo &#39;export PYTHON_ENV=&quot;dev&quot;&#39; &gt;&gt; ~/.bash_profile
QindeMacBook-Pro-2:~ source ~/.bash_profile
</code></pre>

<blockquote>
<p>这是在Mac上的操作，其它linux系统操作方式类似，可能文件名不太一样，Google一下就可以找到，在此不赘述。</p>
</blockquote></li>
<li><p>在生产主机上设置环境变量</p>

<pre><code class="language-shell">cm@iZbp13ifgrbntjy6yxbha4Z:~$  echo &#39;export PYTHON_ENV=&quot;prd&quot;&#39; &gt;&gt; ~/profile
cm@iZbp13ifgrbntjy6yxbha4Z:~$ source .profile
</code></pre>

<blockquote>
<p>这是在ubuntu上的操作方法，做参考。</p>
</blockquote></li>
<li><p>配置代码</p>

<pre><code class="language-python">import os
env = os.environ.get(&#39;PYTHON_ENV&#39;)

if env == &#39;dev&#39;:
   book_file_folder = &quot;/Users/qin/Documents/tmp/book/&quot;
else:
   book_file_folder = &quot;/home/cm/book/&quot;
</code></pre>

<p>这样，在开发的过程中就可以梳理线上的配置，通过环境变量来做开关，发布后不需要修改代码就可以让程序指向生产环境的配置。相同的办法可以用在避免代码中出现敏感配置的场景。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[django 通过thread实现异步任务]]></title>
    <link href="blog.codingroad.com/python-django-asyn-task.html"/>
    <updated>2017-03-29T21:54:14+08:00</updated>
    <id>blog.codingroad.com/python-django-asyn-task.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">业务场景</h2>

<p>业务人员说合作方拿来了几本书的txt文件，需要导入平台，而且以后会是常态化的工作，需要开发功能来实现。</p>

<h2 id="toc_1">分析</h2>

<p>txt文档中包含大量章节的内容，导入时由于章节比较多，整个过程时间不可控，如果让浏览器同步等待响应结果，很可能会出现响应超时的情况。</p>

<p>所以我们需要通过异步处理的方式来实现，简单看了一下，通过Thread就可以实现这个需求，大致流程如下：</p>

<pre><code class="language-sequence">浏览器-&gt;服务端: create import task
Note right of 服务端: 检查参数
Note right of 服务端: 在task表中创建任务记录
Note right of 服务端: 启动异步线程
服务端--&gt;浏览器: taskid
Note right of 服务端: 异步线程处理task
浏览器-&gt;服务端: get task status
服务端--&gt;浏览器: task status
</code></pre>

<h2 id="toc_2">Demo代码</h2>

<pre><code class="language-python">from django.http import HttpResponse
from django.shortcuts import render_to_response
from django.template import RequestContext
import threading
import datetime

# 执行具体任务的异步线程
class TaskThread(threading.Thread):
    def run(self):
        import time

        for i in range(20):
            time.sleep(1)
            print datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;),&quot;%s&quot; % (self.getName(),)


def CreateTask(request):
    taskThread = TaskThread()
    taskThread.start()
    # testThread.join() # 如果加上就会等线程执行完才响应，在我们这个场景下不加
    return HttpResponse(datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;))
</code></pre>

<p>在上述demo中，访问CreateTask时，浏览器会迅速得到内容为当前时间的反馈，但是后台还会持续执行异步线程，每秒打印一次时间信息，持续20次。</p>

<h2 id="toc_3">实现效果</h2>

<p><img src="media/14907956549591/14908834885507.gif" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python-发送邮件]]></title>
    <link href="blog.codingroad.com/python-send-email.html"/>
    <updated>2017-04-06T21:33:37+08:00</updated>
    <id>blog.codingroad.com/python-send-email.html</id>
    <content type="html"><![CDATA[
<pre><code>#coding:utf-8
__author__ = &#39;zhangbo&#39;

import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

# reciver: 收件人的邮箱，为列表，支持多个收件人 
# title: 邮件标题
# html: 发送的html代码
def send_html_email(reciver, title, html):
    # 发件人的邮箱
    me = &quot;sender@mailserver.com&quot;
    msg = MIMEMultipart(&#39;alternative&#39;)
    msg[&#39;Subject&#39;] = title
    msg[&#39;From&#39;] = me
    msg[&#39;To&#39;] = &#39;,&#39;.join(reciver)

    part2 = MIMEText(html, &#39;html&#39;, &#39;utf-8&#39;)
    msg.attach(part2)

    try:
        s = smtplib.SMTP()
        # 发件服务器
        s.connect(&quot;smtp.mailserver.com&quot;, 25)
        # 登陆发件人的账号和密码
        s.login(me, &#39;password&#39;)
        s.sendmail(me, reciver, msg.as_string())
        s.quit()
        return True
    except Exception as e:
        print e
        return False

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[nginx + uwsgi 部署bottle]]></title>
    <link href="blog.codingroad.com/use-nginx-deploy-bottle-project.html"/>
    <updated>2017-04-11T13:46:12+08:00</updated>
    <id>blog.codingroad.com/use-nginx-deploy-bottle-project.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">安装</h2>

<pre><code>apt-get install  uwsgi uwsgi-plugin-python nginx
</code></pre>

<h2 id="toc_1">配置</h2>

<h3 id="toc_2">uwsgi</h3>

<p>配置文件在 <code>/etc/uwsgi/apps-available/bottle.ini</code></p>

<pre><code>[uwsgi]
socket = /run/uwsgi/app/bottle/socket
chdir = /var/www/bottle
master = true
plugins = python
file = app.py
uid = www-data
gid = www-data
</code></pre>

<pre><code>ln -s /etc/uwsgi/apps-available/bottle.ini /etc/uwsgi/apps-enabled/bottle.ini
</code></pre>

<h3 id="toc_3">nginx</h3>

<p>配置文件在 <code>/etc/nginx/conf.d/bottle.conf</code></p>

<pre><code>upstream _bottle {
    server unix:/run/uwsgi/app/bottle/socket;
}

server {
    listen [::]:80;
    listen 80;
    server_name deb.ngx.cc;
    root /var/www/bottle;

    location / {
        try_files $uri @uwsgi;
    }

    location @uwsgi {
        include uwsgi_params;
        uwsgi_pass _bottle;
    }
}
</code></pre>

<h2 id="toc_4">启动</h2>

<pre><code>service uwsgi restart
service nginx restart
</code></pre>

<h2 id="toc_5">问题处理</h2>

<h3 id="toc_6">启动失败</h3>

<p>查看uwsgi和nginx的日志，查找原因</p>

<ul>
<li>uwsgi日志: /var/logs/uwsgi/app/</li>
<li>nginx日志: /var/logs/nginx/error.log</li>
</ul>

<h3 id="toc_7">nginx报连接upstream时权限不足</h3>

<p>主要原因是nginx是需要运行在web-data用户和组下，对应的uwsgi的socket文件也需要是该用户权限。</p>

<h3 id="toc_8">bottle运行时print中文时报错</h3>

<p>主要原因是编码问题，暂未跟进处理 </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python使用MySQLdb时报'MySQL server has gone away']]></title>
    <link href="blog.codingroad.com/python-mysql-has-gone-away.html"/>
    <updated>2017-04-12T08:18:16+08:00</updated>
    <id>blog.codingroad.com/python-mysql-has-gone-away.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">1、现象</a>
</li>
<li>
<a href="#toc_1">2、原因</a>
</li>
<li>
<a href="#toc_2">3、解决方案</a>
</li>
<li>
<a href="#toc_3">4、效果</a>
</li>
</ul>


<h2 id="toc_0">1、现象</h2>

<p>在bottle项目中，自己使用mysqldb连接数据库来执行SQL，在程序启动的时候会初始化数据连接，然后全局共享这个连接。</p>

<p>但是在程序运行一段时间后就会出现执行SQL失败的情况，重启后即可恢复。</p>

<p>对应的错误日志如下：</p>

<pre><code>2017-04-09 13:45:25,624|ERROR|MySQL.py|Line:67|Run Select Failed, SQL=
 select userid, companyid, role, status from dw_admin_user where username = &#39;guash&#39; and password = &#39;6F0E9B51C72BA95911638B3971F&#39;  
, ResKeys=[&#39;userid&#39;, &#39;companyid&#39;, &#39;role&#39;, &#39;status&#39;], Error=(2006, &#39;MySQL server has gone away&#39;)
</code></pre>

<h2 id="toc_1">2、原因</h2>

<p>这个项目在晚间没有人访问，长时间没有执行SQL，导致MySQL服务端将连接中断，再次执行SQL时就会出现此错误。</p>

<h2 id="toc_2">3、解决方案</h2>

<p>在执行SQL的动作前加一个ping操作，判断连接是否存在，如果不存在则自动重新连接。</p>

<pre><code class="language-python">
    def run_select(self, sql, reskeys):
        if not self.connected:
            res = self.connect()
            if not res:
                return None

        try:
            # ping操作，判断连接是否存在，不存在则自动重新连接
            self._mysql.ping(True)
            
            cursor = self._mysql.cursor()
            self.logger.info(&quot;run select: SQL=\n%s \n, ResKeys=%s, db=%s&quot; % (sql, str(reskeys), self.dbname))
            cursor.execute(sql)
            rows = cursor.fetchall()
            return rows
        except Exception as e:
            self.logger.error(&quot;Run Select Failed, SQL=\n%s \n, ResKeys=%s, Error=%s&quot; % (sql, str(reskeys), e.__str__()))
            return None
</code></pre>

<h2 id="toc_3">4、效果</h2>

<p>运行两天未出现之前问题，继续观察。<br/>
抽空可以研究一下django的源码，因为在django项目中从未出现此类问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[域名解析情况监控]]></title>
    <link href="blog.codingroad.com/monitor-dns-resove.html"/>
    <updated>2017-04-21T11:15:15+08:00</updated>
    <id>blog.codingroad.com/monitor-dns-resove.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">新增信息收集脚本</h2>

<p>/root/script/dns/checkdns.sh</p>

<pre><code class="language-sh">LOG_FOLDER=/root/script/dns/logs/
LOG_FILE=${LOG_FOLDER}`date &quot;+%Y-%m-%d&quot;`.txt
DOMAIN=www.4yt.cn

echo &quot;`date &quot;+%Y-%m-%d %H:%M:%S&quot;`;   `dig ${DOMAIN}  | grep ${DOMAIN}  | grep -v &#39;;&#39;`;  `ping ${DOMAIN} -c 1 -n | head -2 | grep -v &#39;PING&#39; `&quot;  &gt;&gt;  ${LOG_FILE}
</code></pre>

<h2 id="toc_1">增加crontab，每分钟收集一次</h2>

<pre><code class="language-sh">*/1 * * * * sh /root/script/dns/checkdns.sh
</code></pre>

<h2 id="toc_2">结果日志</h2>

<pre><code class="language-sh">root@iZ231r70b7pZ:~/script/dns# more logs/2017-04-21.txt 

2017-04-21 10:59:01;   www.4yt.cn.              3600    IN      A       59.110.19.86;  64 bytes from 59.110.19.86: icmp_seq=1 ttl=58 time=33.9 ms
2017-04-21 11:00:01;   www.4yt.cn.              3420    IN      A       59.110.19.86;  64 bytes from 59.110.19.86: icmp_seq=1 ttl=58 time=33.7 ms
2017-04-21 11:01:01;   www.4yt.cn.              218     IN      A       59.110.19.86;  64 bytes from 59.110.19.86: icmp_seq=1 ttl=58 time=33.7 ms
2017-04-21 11:02:01;   www.4yt.cn.              408     IN      A       59.110.19.86;  64 bytes from 59.110.19.86: icmp_seq=1 ttl=58 time=33.6 ms
2017-04-21 11:03:01;   www.4yt.cn.              348     IN      A       59.110.19.86;  64 bytes from 59.110.19.86: icmp_seq=1 ttl=58 time=33.6 ms
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浙江移动劫持404、500等响应码问题处理]]></title>
    <link href="blog.codingroad.com/zhejiang-cmcc-http-status-hijacking.html"/>
    <updated>2017-05-11T16:05:49+08:00</updated>
    <id>blog.codingroad.com/zhejiang-cmcc-http-status-hijacking.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">问题现象</h2>

<p>问题发现：网站改版升级后，原URL会失效，所以我们在tomcat中将404错误指向error.jsp页面，此页面加载后发起重定向到新的首页。</p>

<p>在wifi环境下测试正常，使用错误URL访问能正常跳转。但是在移动4G网络下发现无法进行正常跳转，而是进入下述图片中的页面。</p>

<p><img src="media/14944899493728/14944901728602.jpg" alt=""/></p>

<h2 id="toc_1">问题分析</h2>

<p>这是第一次遇到这种问题，经过网上查资料，学到了 <code>响应码劫持</code> 这个新词汇。意思是攻击者在发现response头中的status为404、500等异常时，将响应的数据进行修改的劫持手段。</p>

<p>在这个场景中，浙江移动就是为了推广自己的产品，而将404错误劫持到其定义的页面上。忽视了网站本身对404错误响应的body中还会有逻辑处理的场景，导致网站访问出现异常。</p>

<p>对于这种行为，我只想说 <strong>呵呵</strong>！</p>

<h2 id="toc_2">问题解决</h2>

<p>通过上述分析，确定问题原因是在响应码上，那么应对起来就简单多了。我们只需要将响应码强制修改成200就好了。在error.jsp中我们通过如下代码强制修改响应码：</p>

<pre><code class="language-jsp">&lt;%
  response.setStatus(200);
%&gt; 
</code></pre>

<blockquote>
<p>注：我们第一次修改并没有成功，后面将代码加在<code>&lt;/body&gt;</code>前面就可以了，原因未知。</p>
</blockquote>

<h2 id="toc_3">其它分析</h2>

<p>后面我做了https的404错误测试，发现浙江移动就不会进行劫持，所以还是应该尽量使用https。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信的坑-微信服务器重发页面请求的问题]]></title>
    <link href="blog.codingroad.com/wechat-multiple-requst.html"/>
    <updated>2017-05-17T17:31:37+08:00</updated>
    <id>blog.codingroad.com/wechat-multiple-requst.html</id>
    <content type="html"><![CDATA[
<p>这是一个大坑，可能有人还没有注意到这个问题，但它确实存在，而且可能会影响你的统计数据。</p>

<h2 id="toc_0">现象</h2>

<p>近期我们在微信上做推广后，做数据分析时发现一些异常数据：</p>

<ul>
<li>大量用户来自天津、上海的ip</li>
<li>这些用户每次只访问一个页面，产生session之后就再也不来了</li>
</ul>

<p>最初我们认为是下游推广渠道在坑我们钱，用天津和上海的服务器来刷访问用户数，近而骗取我们的推广费用。</p>

<p>然而和多家合作方推广后都发现同样的问题，所以觉得这个事情并有这么简单。经过一系列的排查之后才发现，这个大坑居然是微信造成的。</p>

<h2 id="toc_1">问题定位</h2>

<p>为了确认这些“用户”是真用户，还是假用户，我们尝试了大量手段来分析，此处省略5000字，Fuck！</p>

<p>最终我们联想到了UC浏览器预读功能，开始怀疑是某个地方的预读导致，于是按这个思路来进行定位。</p>

<blockquote>
<p>关于UC浏览器的预读功能：开启此功能后，在读小说时，浏览器会分析页面中的“下一章”链接，并后台提前请求服务端拿到响应数据，等用户点下一章的时候，页面就可以瞬间展示出来。</p>
</blockquote>

<h3 id="toc_2">定位思路：</h3>

<ul>
<li>组装一个没有人会访问的URL</li>
<li>通过微信浏览器访问该URL</li>
<li>监控服务端日志，确认是否会有其它人发起同样的请求，如果有，那就说明微信或者中间的网络服务商有人在预读。</li>
</ul>

<h3 id="toc_3">定位过程</h3>

<ol>
<li><p>组装一个没有人会访问的URL</p>

<ul>
<li>正常的URL：/bookinfo/148161271068074.html</li>
<li>组装的URL：/bookinfo/148161271068074.html?c=fuckwx</li>
</ul>

<blockquote>
<p>说明一下：为了验证这个问题，我们另外搭了一个服务器，根本不会有用户访问。而且这个世界上应该没有人会同时带fuckwx这个参数来访问我的服务器。</p>
</blockquote></li>
<li><p>微信浏览器访问</p></li>
<li><p>监控服务端accesslog</p>

<pre><code class="language-shell">wap@iZ2zeg0900kzwn7hnqg3pzZ:~/app/apache-tomcat-7.0.68/logs$ tailf  localhost_access_log.2017-05-17.txt | grep fuckwx
20170517172145|045|112.17.238.22|2833|GET|/bookinfo/148161271068074.html|200|19|?c=fuckwx|Mozilla/5.0 (iPhone; CPU iPhone OS 8_1_2 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Mobile/12B440 MicroMessenger/6.5.3 NetType/4G Language/zh_CN
20170517172154|054|117.185.27.114|2832|GET|/bookinfo/148161271068074.html|200|8|?c=fuckwx|Mozilla/5.0 (iPhone; CPU iPhone OS 10_2_1 like Mac OS X) AppleWebKit/602.4.6 (KHTML, like Gecko) Mobile/14D27 MicroMessenger/6.5.5 NetType/WIFI Language/zh_CN
</code></pre>

<p><strong>到这里已经基本可以确认，就是有人在重发我的请求</strong><br/>
我的ip是 <code>112.17.238.22</code> 浙江移动的IP。<br/>
而这个重发的ip是 <code>117.185.27.114</code> 上海移动的IP。</p></li>
<li><p>为了确认是微信的问题，还是中间网络服务端的问题。我们通过更换浏览器，更换网络环境进行对比测试，结果发现：只有在微信浏览器下会出现这个问题，与网络环境无关。</p></li>
<li><p>抓包信息http头结果如下:</p>

<ul>
<li><p>真实用户请求<br/>
<img src="media/14950134973267/14950155228633.jpg" alt=""/></p></li>
<li><p>微信服务器请求</p></li>
</ul>

<p><img src="media/14950134973267/14950156475859.jpg" alt=""/> </p></li>
</ol>

<h2 id="toc_4">问题分析</h2>

<p>通过上述的数据我们发现以下问题<br/>
1. 微信是在真实用户请求后几秒内，接着发起一次同样地址的请求。<br/>
2. 微信在请求的时候更换了UA。<br/>
3. 微信在请求的时候没有携带cookie。<br/>
4. 微信是完全随机IP进行访问，目前来看应该是有好几个段的IP在做这个事情，主要集中在天津和上海。<br/>
5. 微信是完全随机进行这样的重发操作，找不到任何规律。</p>

<p>这些特性放在一起，就很尴尬了啊：<strong>服务端完全不知道这个请求是机器人还是真实用户</strong>，我们统计出来的访问用户数就明显不准确了，而且会影响人均PV等统计数据。</p>

<h2 id="toc_5">问题处理</h2>

<p>暂时想到的是通过js来埋点的方式进行用户统计，但是需要验证这个微信是否会对ajax请求做同样的重发操作。</p>

<p>其它方案还是没有想到：</p>

<p>如果有哪位读者想到了求分享思路。</p>

<p>同时如果有微信内部的人看到了这个文章，麻烦解惑一下微信这么做的原因。以及我们的应对方案。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker安装zabbix-server]]></title>
    <link href="blog.codingroad.com/use-docker-deploy-zabbix.html"/>
    <updated>2017-05-26T07:53:09+08:00</updated>
    <id>blog.codingroad.com/use-docker-deploy-zabbix.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">环境</a>
</li>
<li>
<a href="#toc_1">安装步骤</a>
<ul>
<li>
<a href="#toc_2">安装docker</a>
</li>
<li>
<a href="#toc_3">docker的三个基本概念</a>
</li>
<li>
<a href="#toc_4">获取zabbix-server 镜像</a>
</li>
<li>
<a href="#toc_5">创建数据库</a>
</li>
<li>
<a href="#toc_6">配置容器</a>
</li>
<li>
<a href="#toc_7">运行容器</a>
</li>
<li>
<a href="#toc_8">了解容器的运行状态</a>
</li>
<li>
<a href="#toc_9">进入zabbix的web页面</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">zabbix-server基本设置</a>
<ul>
<li>
<a href="#toc_11">设置成中文</a>
</li>
<li>
<a href="#toc_12">增加第一台主机</a>
</li>
</ul>
</li>
<li>
<a href="#toc_13">附录</a>
<ul>
<li>
<a href="#toc_14">拉起容器后初始化数据库失败的问题处理</a>
</li>
</ul>
</li>
</ul>


<p>以前折腾过一次部署zabbix环境，觉得比较麻烦，特别是php环境，当时不是很熟悉，折腾了很久。<br/>
现在我们的业务上也需要zabbix，在部署的时候首先想到的就是能不能用docker来实现快速部署，查了一些资料，发现真的可行，于是便在自己的虚拟机上搭了一套。说明如下</p>

<h2 id="toc_0">环境</h2>

<p>物理机：MacBookPro</p>

<ul>
<li>虚拟ip：192.168.132.1</li>
</ul>

<p>虚拟机：ubuntu 14.04 64：</p>

<ul>
<li>虚拟ip：192.168.132.129</li>
<li>docker ip：172.17.0.1</li>
</ul>

<h2 id="toc_1">安装步骤</h2>

<h3 id="toc_2">安装docker</h3>

<p>网上有一大堆材料来说明，我就不在详细说明了。我用官方的一键脚本直接用来安装</p>

<pre><code class="language-sh">curl -sSL https://get.docker.com/ | sh
</code></pre>

<p>当然如果怕从国外服务器下载慢的话，可以用阿里的镜像</p>

<pre><code class="language-sh">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -
</code></pre>

<p>安装完成后执行 <code>docker version</code> 命令可以查看到docker的版本信息说明安装成功。</p>

<h3 id="toc_3">docker的三个基本概念</h3>

<p>简单介绍一下docker的三个最关键的概念。</p>

<ul>
<li>image：镜像 就是别人制作好的环境，里面包含程序、资源和配置信息。上传的镜像仓库里面，你要用的话就下载。类似于用光盘安装操作系统时，光盘的内容就是个image。</li>
<li>container：容器 这是将image运行进来后的实例，可以理解为image是一个程序的资源文件包，而容器是运行这个image后产生的一个进程实例。我们可以用同一份image运行多个container。</li>
<li>Repository：仓库 用于存放大家制作好的image镜像，其他人有需求的时候直接在仓库中下载就可以了。docker官方提供了docker hub仓库，里面有大量的镜像可以使用。因为国外下载比较慢，你也可以使用国内的一些源来加速，比如阿里云就提供这样的服务。当然随着项目的需要，你也可以自己搭建私有仓库。</li>
</ul>

<h3 id="toc_4">获取zabbix-server 镜像</h3>

<p>经过分析，我在docker hub上找到了monitoringartist/zabbix-xxl镜像，它目前已经支持到最新的zabbix 3.2版本，而3.1版本之后zabbix官方就内置了中文的语言包，所以就用它了。</p>

<p>使用下面这个命令下载镜像</p>

<pre><code class="language-sh">root@ubuntu:~# docker pull monitoringartist/zabbix-xxl
</code></pre>

<p>下载完成后通过<code>docker image ls</code> 命令查看本地的镜像列表</p>

<pre><code class="language-sh">root@ubuntu:~# docker image ls
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
monitoringartist/zabbix-xxl   latest              701478bab1b3        2 weeks ago         771MB
</code></pre>

<p>可以看到这个镜像打开后有771MB，还是蛮大的。</p>

<h3 id="toc_5">创建数据库</h3>

<p>因为zabbix需要用到数据库，我物理机上已经装过了MySQL数据库，所以只需要再里面新增一个database和user就可以了。</p>

<pre><code class="language-sh">CREATE DATABASE zabbix character set utf8 collate utf8_bin;

CREATE USER &#39;zabbix&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;
 
GRANT all privileges ON zabbix.* TO &#39;zabbix&#39;@&#39;%&#39;;
</code></pre>

<blockquote>
<p>注： 创建DATABASE的时候最好指定字符集，我在第一次创建的时候没有指定，导致后面zabbix无法使用数据库。</p>
</blockquote>

<h3 id="toc_6">配置容器</h3>

<p>虽然可以通过docker run后面加一堆参数的方式来直接拉起容器，但是这样参数不便于管理。所以我使用docker-compose的方式来管理这个容器的配置。</p>

<p>新建一个配置文件 <code>docker-compose.yml</code>， 内容如下</p>

<pre><code class="language-yaml">version: &#39;2&#39;
services:
  zabbix-server:
    image: monitoringartist/zabbix-xxl:latest 
    container_name: zabbix-server-2
    network_mode: &quot;bridge&quot;
    restart: always
    ports:
      - &quot;18888:80&quot;
      - &quot;10052:10051&quot;
    volumes:
      - /etc/localtime:/etc/localtime:ro
    environment:
      - ZS_DBHost=192.168.132.1
      - ZS_DBUser=zabbix
      - ZS_DBPassword=123456
      - ZS_DBName=zabbix
</code></pre>

<p>说明：</p>

<ul>
<li>container_name 指定容器的名字。</li>
<li>ports是做端口映射，这么配置之后，访问虚拟机的18888端口的请求就会转发给容器的80端口。</li>
<li>enviroment里面我配置的主要是数据库的信息，因为MySQL是安装在物理机上的，所以使用了物理机的ip</li>
</ul>

<blockquote>
<p>注：docker-compose是官方提供的一个工具，初始安装docker的时候并不会同步安装这个工具，需要执行 <code>pip install docker-compose</code> 命令来安装这个工具。</p>
</blockquote>

<h3 id="toc_7">运行容器</h3>

<p>使用docker-compose来加载上面写的配置文件，拉起一个容器。</p>

<pre><code class="language-sh">root@ubuntu:~/app/zabbix/monitoringartist#  docker-compose up -d
</code></pre>

<blockquote>
<p>注：需要在配置文件的目录运行这个命令。</p>
</blockquote>

<p>这样如果不出意外，容器运行后就会连接数据库，初始化表结构和数据，然后就可以使用了。<br/>
但是我在这里碰到了初始化表结构和数据失败的问题，导致服务无法使用，处理方法见附录。</p>

<h3 id="toc_8">了解容器的运行状态</h3>

<ul>
<li><p>查看容器运行日志</p>

<pre><code>docker logs -f zabbix-server-2
</code></pre></li>
<li><p>进入容器系统的命令行<br/>
因为我们的镜像其实是包含了一个微型的linux操作系统，然后再上面安装zabbix的，所以它是可以登陆进去并打开shell窗口的。</p>

<pre><code>docker exec -ti zabbix-server-2 /bin/bash
</code></pre>

<p>这样就可以在容器里面执行shell命令，像维护linux主机一样来操作这个容器了。</p></li>
</ul>

<h3 id="toc_9">进入zabbix的web页面</h3>

<p>在物理机上打开浏览器，访问<a href="http://192.168.132.129:18888/">http://192.168.132.129:18888/</a><br/>
就可以打开web页面了，用默认用户名Admin/zabbix登陆进去就可以了。</p>

<h2 id="toc_10">zabbix-server基本设置</h2>

<h3 id="toc_11">设置成中文</h3>

<p>毕竟之前没怎么用过zabbix，纯英文的界面学习成本比较高，所以上来第一件事情就是将其设置成中文。</p>

<p>设置成中文非常简单，点右上角的小人，然后在语言那里选中文就好了<br/>
<img src="media/14957563898448/14957601173919.jpg" alt=""/></p>

<p>修改后页面就成了中文的了，但是还有一个问题需要处理，否则chart的界面里面会有乱码。参考链接 <a href="http://coolnull.com/3395.html">http://coolnull.com/3395.html</a></p>

<h3 id="toc_12">增加第一台主机</h3>

<p>在配置--&gt;主机中找到Zabbix server，点启用，就完成了将zabbix运行的主机加入监控的动作。</p>

<p>在主机聚合图里面就可以看到这些统计信息了。</p>

<p><img src="media/14957563898448/14957605537200.jpg" alt=""/></p>

<h2 id="toc_13">附录</h2>

<h3 id="toc_14">拉起容器后初始化数据库失败的问题处理</h3>

<p>因为我第一次创建数据库的时候没有设置字符集，导致拉起容器的时候初始化数据库失败。</p>

<p>为了解决这个问题，我们需要进行容器的命令行，手动去执行sql文件，方法如下：</p>

<ul>
<li><p>进入容器命令行，方法参见上面的介绍</p>

<pre><code class="language-sh">root@ubuntu:~/app/zabbix/monitoringartist# docker exec -ti zabbix-server-2 /bin/bash
[root@4fe2124b522a /]# 
</code></pre></li>
<li><p>查找初始化的sql文件</p>

<pre><code class="language-sh">[root@4fe2124b522a /]# find / -name &#39;*.sql&#39;
/usr/local/src/zabbix/database/mysql/images.sql
/usr/local/src/zabbix/database/mysql/data.sql
/usr/local/src/zabbix/database/mysql/schema.sql
</code></pre></li>
<li><p>手动导入</p>

<pre><code class="language-sh">[root@4fe2124b522a /]# cd /usr/local/src/zabbix/database/mysql/
[root@4fe2124b522a mysql]# mysql -u zabbix -p123456 zabbix2 -h 192.168.132.1 &lt; schema.sql
[root@4fe2124b522a mysql]# mysql -u zabbix -p123456 zabbix2 -h 192.168.132.1 &lt; images.sql
[root@4fe2124b522a mysql]# mysql -u zabbix -p123456 zabbix2 -h 192.168.132.1 &lt; data.sql
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[django 表单开启csrf验证]]></title>
    <link href="blog.codingroad.com/python-django-csrf-form.html"/>
    <updated>2017-08-14T15:56:56+08:00</updated>
    <id>blog.codingroad.com/python-django-csrf-form.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">template层</h2>

<pre><code class="language-html">&lt;form class=&quot;form-horizontal&quot; method=&quot;post&quot; id=&quot;iptFrm&quot; action=&quot;{%url &#39;api_import_post&#39; %}&quot;&gt;{% csrf_token %}
&lt;/form&gt;
</code></pre>

<h2 id="toc_1">view层</h2>

<pre><code class="language-python">
from django.views.decorators.csrf import csrf_protect

@csrf_protect
def import_post(request):
    return HttpResponse(&quot;Success&quot;)
</code></pre>

<h2 id="toc_2">settings</h2>

<p>请确认MIDDLEWARE中引入了 <code>django.middleware.csrf.CsrfViewMiddleware</code> ，正常情况下是默认引入的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[django template循环显示内容]]></title>
    <link href="blog.codingroad.com/python-django-template-repeat.html"/>
    <updated>2017-08-14T16:01:55+08:00</updated>
    <id>blog.codingroad.com/python-django-template-repeat.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">需求</h2>

<p>如下图标红框的区块所示，我在blog的文章列表页，每行要显示2个文章。</p>

<p>如果是在程序里面大家都知道用mod去控制循环就好了，但是在template里面确不支持mod方法，那应该怎样实现呢？</p>

<p><img src="media/15026977152618/15026991225998.jpg" alt=""/></p>

<h2 id="toc_1">方法</h2>

<p>利用template自己的变量forloop可以实现我们期望的效果，具体方法如下：</p>

<p>在view层准备好con_post_list 文章列表，然后在template中用如下方法实现：</p>

<pre><code class="language-html">    {% if con_post_list %}
        {% for conpost in con_post_list %}
            {% if forloop.counter0|divisibleby:2 %}&lt;div class=&quot;row&quot;&gt;{% endif %}
                &lt;div class=&quot;col-xs-12 col-md-6&quot;&gt;
                    &lt;div class=&quot;media&quot;&gt;
                      &lt;hr&gt;
                      &lt;div class=&quot;media-left&quot;&gt;
                        &lt;a href=&quot;#&quot;&gt;
                            &lt;img class=&quot;media-object&quot; src=&quot;&quot; width=25&gt;
                        &lt;/a&gt;
                      &lt;/div&gt;
                      &lt;div class=&quot;media-body&quot;&gt;
                        &lt;h4 class=&quot;media-heading&quot;&gt;{{ conpost.title }}&lt;/h4&gt;
                        &lt;p&gt;发表于: {{ conpost.publishdate }}&lt;/p&gt;
                        &lt;p&gt;{{ conpost.description }}&lt;/p&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;br&gt;
                &lt;/div&gt;
            {% if forloop.counter|divisibleby:2 %}&lt;/div&gt;{% endif %}
        {% endfor %}
    {% endif %}
</code></pre>

<p>最核心的部分如下</p>

<pre><code class="language-html">{% if forloop.counter0|divisibleby:2 %}&lt;div class=&quot;row&quot;&gt;{% endif %}
{% if forloop.counter|divisibleby:2 %}&lt;/div&gt;{% endif %}
</code></pre>

<p>这个表示在循环中，每循环两次则展示if里面的内容，使用这个特性刚好实现我们的需求。</p>

<h2 id="toc_2">More</h2>

<p>forloop是用来做循环控制的，常用的变量有</p>

<ul>
<li>forloop.counter0 获取当前迭代值，从0开始计数</li>
<li>forloop.counter  获取当前迭代值，从1开始计数</li>
<li>forloop.first 是否第1次进入循环</li>
<li>forloop.last 是否最后1次进入循环</li>
</ul>

<p>可以在template中直接使用，如</p>

<pre><code class="language-html">{% for conpost in con_post_list %}
    {% if forloop.first %} 
        &lt;h1&gt;start-开始循环&lt;/h1&gt;
    {% endif %}
    &lt;h2&gt;{{ forloop.counter }} - {{ conpost.title }}&lt;/h2&gt;
    {% if forloop.last %} 
        &lt;h1&gt;end&lt;/h1&gt;
    {% endif %}
{% endfor %}
</code></pre>

<p>参考<br/>
<a href="https://docs.djangoproject.com/en/1.11/ref/templates/builtins/#for">django-template-builtins-for</a></p>

]]></content>
  </entry>
  
</feed>
